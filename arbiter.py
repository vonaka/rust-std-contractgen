import subprocess

import style

from configuration import Config
from conversation import Conversation, LongInputException


class Arbiter:

    def __init__(self):
        self.grade = -1
        self.conversation = Conversation(Config.arbiter_model, Config.arbiter_region, Config.prompt_dir)

    def hi(self):
        self.conversation.add_system_prompt(prompt_str='Hi!')
        return self.conversation.hi()

    def assess_worker(self, original_file: str, worker_output: str):
        Config.verboseprint(f'Assessing the output with {Config.arbiter_model}')

        self.grade = -1

        # TODO: Why not add this during initialization?
        self.conversation.add_system_prompt(prompt_filename='arbiter_system_prompt.txt')
        self.conversation.remove_checkpoint()
        self.conversation.send_file_with_message(
            """
            Please assess the following contracts generated by the worker for the attached file:
            """ + "\n" + worker_output,
            original_file)
        self.conversation.set_checkpoint()
        if Config.gen_type_invariants:
            self.conversation.send_message(
                msg_str="""
                In addition to what you already know, the worker was also asked to generate type
                invariants. The text bellow contains the instructions the worker received. You
                should take this into account in your evaluation of the worker. Please read the
                instructions carefully, as they directly impact the expected output format. In
                particular, the worker MUST NOT output contracts for functions that are not
                unsafe - in such cases, it may only generate type invariants. Furthermore, if
                the worker has converted certain contracts into type invariants, those contracts
                MUST be removed from the list of generated contracts, leaving only the
                corresponding invariants.

                Additional Assessment Criterion:
                Type Invariants and Safe Functions: The worker must not generate contracts for safe
                functions. Instead, it must generate the corresponding type invariants and output
                them in the correct format.
                Importance: IMPORTANT

                Below are the instructions provided to the worker.
                """,
                msg_filename='worker_type_invariant.txt'
            )
        self.conversation.converse()
        return self.get_grade()

    def assess_harnesses(self, worker_output: str):
        Config.verboseprint(f'Assessing the generated harnesses with {Config.arbiter_model}')

        self.grade = -1

        self.conversation.send_message_str(
            """
            I will send you the instructions that the worker follow to generate harnesses
            (proofs) for the functions it annotated. Please carefully study these instructions,
            as I will then ask you to assess the harnesses generated by the worker.
            """
        )
        self.conversation.send_message_from_file('harnesses.txt')
        self.conversation.converse()
        self.conversation.send_message_str(
            f"""
            IMPORTANT:

            1. Contract harnesses MUST NOT use `assert` or `assume` (`kani::assume`). Kani
               implicitly assumes that preconditions hold.
            2. If the worker wraps harnesses in the `verify` module, that is acceptable and
               you should not complain.
            3. Just like the code of contracts, the code of harnesses MUST be valid Rust.
               For instance, worker can only call a method on a variable if that method is
               defined for the type of that variable.
            4. `kani::any()` can be used only with primitive types.

            And now please assess the following harnesses generated by the worker:

            {worker_output}
            """
        )
        self.conversation.converse()
        return self.get_grade()

    def reassess_worker(self, worker_output: str):
        Config.verboseprint(f'\tRe-assessing the output')

        self.grade = -1
        self.conversation.send_message_str(
            """
            Please re-assess the following updated worker's output:
            """ + "\n" + worker_output)
        self.conversation.converse()
        return self.get_grade()

    def ask_to_improve(self):
        if self.grade <= 0 or self.grade >= 5:
            return ''

        Config.verboseprint(f'\tPreparing refinement instructions')

        self.conversation.send_message_str(
            """
            Provide precise, actionable instructions that the worker should follow
            to improve or correct its output.

            Print only these instructions.
            """
        )
        return self.conversation.converse()

    def get_grade(self):
        self.conversation.send_message_str(
            """
            Print your grade. Print only the number between 1 and 5 without any explanation.
            """
        )
        grade_str = self.conversation.converse()
        grade_str, _, _ = grade_str.partition(' ')
        while grade_str:
            try:
                self.grade = int(grade_str)
                break
            except:
                grade_str = grade_str[:-1]
        if self.grade >= 1 and self.grade <= 5:
            Config.verboseprint(f'\tGrade: {self.grade}/5')
        return self.grade

    def log_summary(self):
        if self.grade < 0:
            return
        self.conversation.send_message_str(
            """
            Print short (one to two phrases long) summary of why you grade it that way.
            """
        )
        Config.log(self.conversation.converse())

    def try_to_compile(self):
        Config.verboseprint(f'Trying to compile')

        if Config.source_dir.startswith("https://"):
            Config.verboseprint(style.yellow(
                f'\tRemote source cannot be used for a compilation check, skipping'))
            return True

        r = subprocess.run(["which", "timeout"],
                           check=False, capture_output=True)
        if r.returncode != 0:
            Config.verboseprint(style.yellow(
                f'\tCannot find `timeout`, skipping'))
            return True

        r = subprocess.run(["timeout", "40", "scripts/run-kani.sh"],
                           cwd=Config.source_dir,
                           capture_output=True,
                           text=True,
                           check=False)
        if not ("error: " in r.stdout or "error[" in r.stdout):
            Config.verboseprint(f'\tLooks fine')
            return True

        try:
            self.conversation.send_message_str(
                """
                The annotated code does not compile! Please review the compilation messages below carefully.
                You should ensure that the worker avoids repeating these or similar mistakes in the future.
                Later, you may be asked to guide the worker in fixing these specific issues.

                Rust compiler output:
                """ + r.stdout
            )
            self.conversation.converse()
        except LongInputException:
            print(style.yellow("Way too faulty... Nevermind"))

        return False
